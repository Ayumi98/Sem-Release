package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
	"strings"

	"github.com/Masterminds/semver"
	"github.com/bradleyfalzon/ghinstallation"
	"github.com/gofrs/uuid"
	"github.com/google/go-github/github"
	"github.com/poc-git/model"
	"github.com/poc-git/semelease"
)

type TagRequest struct {
	Tag     *string `json:"tag,omitempty"`
	Message *string `json:"message,omitempty"`
	Object  *string `json:"object,omitempty"`
	Type    *string `json:"type,omitempty"`
}

func createRelease(owner, repo string) {
	ctx := context.TODO()
	tr := http.DefaultTransport
	itr, _ := ghinstallation.NewKeyFromFile(tr, 22198, 515453, "privatekey.pem")
	client := github.NewClient(&http.Client{Transport: itr})
	u2, _ := uuid.NewV4()
	key := u2.String()
	relear := github.RepositoryRelease{
		TagName:         github.String(key),
		TargetCommitish: github.String("master"),
		Name:            github.String(key),
		Body:            github.String("Nova release " + key),
		Draft:           github.Bool(false),
		Prerelease:      github.Bool(false),
	}
	client.Repositories.CreateRelease(ctx, owner, repo, &relear)
	fmt.Println("NOVO RELEASE CRIADO TAG: ", key)
}

func CaptureRepositoryAndOwner(pullRequest interface{}) (string, string) {
	///mudar esse cara para recursivo
	if (pullRequest) != nil {
		head := pullRequest.(map[string]interface{})
		if head != nil {
			repo := head["head"]
			if repo != nil {
				rp := repo.(map[string]interface{})
				if rp != nil {
					owner := rp["repo"]
					if owner != nil {

						ow := owner.(map[string]interface{})
						repositoryname := ow["name"].(string)
						login := ow["owner"].(map[string]interface{})["login"].(string)
						return repositoryname, login
					}
				}
			}
		}
	}
	return "", ""
}

func CaptureGitWebHook(w http.ResponseWriter, r *http.Request) {
	body, _ := ioutil.ReadAll(r.Body)
	m := map[string]interface{}{}
	json.Unmarshal(body, &m)
	count := 0
	pullRequest := m["pull_request"]
	repositoryname, login := CaptureRepositoryAndOwner(pullRequest)

	for k, v := range m {
		//fmt.Println(k)
		if k == "action" {
			if v == "closed" {
				count++
			}
		}
		if k == "pull_request" {
			msg := v.(map[string]interface{})
			for key, value := range msg {
				if key == "merged" {
					merged := value.(bool)
					if merged {
						count++
					}
				}
			}
		}
		if count > 1 {
			///chamar o release
			createRelease(login, repositoryname)
			break
		}
	}
}

var breakingPattern = regexp.MustCompile("BREAKING CHANGES?")
var commitPattern = regexp.MustCompile("^(\\w*)(?:\\((.*)\\))?\\: (.*)$")

func parseCommit(commit *github.RepositoryCommit) *model.Commit {
	c := new(model.Commit)
	c.SHA = commit.GetSHA()
	c.Raw = strings.Split(commit.Commit.GetMessage(), "\n")
	found := commitPattern.FindAllStringSubmatch(c.Raw[0], -1)
	if len(found) < 1 {
		return c
	}
	c.Type = strings.ToLower(found[0][1])
	c.Scope = found[0][2]
	c.Message = found[0][3]
	c.Change = model.Change{
		Major: breakingPattern.MatchString(commit.Commit.GetMessage()),
		Minor: c.Type == "feat",
		Patch: c.Type == "fix",
	}
	return c
}
func main() {
	//router := mux.NewRouter()
	//router.HandleFunc("/payload", CaptureGitWebHook).Methods("POST")
	//log.Fatal(http.ListenAndServe(":8000", router))
	owner := "eduardokenjimiura"
	repo := "Fiap-Python"
	cl := returnClient()
	ctx := context.TODO()
	cm, _, _ := cl.Repositories.ListCommits(ctx, owner, repo, nil)
	var commits []*model.Commit
	for _, commit := range cm {
		//commit.Commit
		commits = append(commits, parseCommit(commit))

	}
	lastedRelease, _ := GetLatestRelease()

	//	fmt.Println(commits)
	version := semelease.GetNewVersion(commits, lastedRelease)
	//fmt.Println(cm, err, resp)[]
	fmt.Println(version)
	changelog := semelease.GetChangelog(commits, lastedRelease, version)
	fmt.Println(CreateRelease(changelog, version, false, "master"))

}

// CreateRelease ...
func CreateRelease(changelog string, newVersion *semver.Version, prerelease bool, branch string) error {
	tag := fmt.Sprintf("v%s", newVersion.String())
	isPrerelease := prerelease || newVersion.Prerelease() != ""
	ctx := context.TODO()
	owner := "eduardokenjimiura"
	repo := "Fiap-Python"
	opts := &github.RepositoryRelease{
		TagName:         &tag,
		Name:            &tag,
		TargetCommitish: &branch,
		Body:            &changelog,
		Prerelease:      &isPrerelease,
	}
	cl := returnClient()
	_, _, err := cl.Repositories.CreateRelease(ctx, owner, repo, opts)
	if err != nil {
		return err
	}
	return nil
}

// GetLatestRelease ..
func GetLatestRelease() (*model.Release, error) {
	ctx := context.TODO()
	owner := "eduardokenjimiura"
	repo := "Fiap-Python"
	allReleases := make(model.Releases, 0)
	opts := &github.ReferenceListOptions{"tags", github.ListOptions{PerPage: 100}}
	cl := returnClient()
	for {
		refs, resp, err := cl.Git.ListRefs(ctx, owner, repo, opts)
		if resp != nil && resp.StatusCode == 404 {
			return &model.Release{"", &semver.Version{}}, nil
		}
		if err != nil {
			return nil, err
		}
		for _, r := range refs {
			version, err := semver.NewVersion(strings.TrimPrefix(r.GetRef(), "refs/tags/"))
			if err != nil {
				continue
			}
			allReleases = append(allReleases, &model.Release{r.Object.GetSHA(), version})
		}
		if resp.NextPage == 0 {
			break
		}
		opts.Page = resp.NextPage
	}
	var lastRelease *model.Release
	for _, r := range allReleases {
		if r.Version.Prerelease() == "" {
			lastRelease = r
			break
		}
	}

	return lastRelease, nil

}

func returnClient() *github.Client {
	tr := http.DefaultTransport
	itr, err := ghinstallation.NewKeyFromFile(tr, 22198, 515453, "privatekey.pem")
	if err != nil {
		log.Fatal(err)
	}
	client := github.NewClient(&http.Client{Transport: itr})
	//client.Repositories.ListCommits()
	return client
}

// func createTag(owner, repo string, client *github.Client) {
// 	u := fmt.Sprintf("repos/%v/%v/git/tags", owner, repo)

// 	tagRequest := TagRequest{
// 		Tag:     github.String("v-0.0.1"),
// 		Message: github.String("initial version"),
// 		Object:  github.String("3796f797adebb08b0f9d1848c1d2fc34abfb302e"),
// 		Type:    github.String("commit"),
// 	}

// 	req, err := client.NewRequest("POST", u, tagRequest)
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	t := new(TagRequest)
// 	ctx := context.TODO()
// 	resp, _ := client.Do(ctx, req, t)
// 	fmt.Println(resp.StatusCode, resp.Status)
// 	body, _ := ioutil.ReadAll(resp.Body)

// 	fmt.Println(body)
// }
// func main2() {
// 	tr := http.DefaultTransport

// 	ctx := context.TODO()
// 	itr, err := ghinstallation.NewKeyFromFile(tr, 22198, 515453, "privatekey.pem")

// 	if err != nil {
// 		log.Fatal(err)
// 	}

// 	nome := "testelalalalalala"
// 	Description := "repository"
// 	Homepage := "https://github.com"
// 	Private := false
// 	hasissues := true
// 	hasprojects := true
// 	haswiki := true
// 	client := github.NewClient(&http.Client{Transport: itr})
// 	//createTag("eduardokenjimiura", "Fiap-Python", client)

// 	rep := github.Repository{
// 		Name:        &nome,
// 		Description: &Description,
// 		Homepage:    &Homepage,
// 		Private:     &Private,
// 		HasIssues:   &hasissues,
// 		HasProjects: &hasprojects,
// 		HasWiki:     &haswiki,
// 	}
// 	fmt.Println(rep)
// 	pul := github.PullRequestComment{
// 		Path:     github.String("teste.py"),
// 		Position: github.Int(1),
// 		Body:     github.String("sssssssssssssssssssssalready commented"),
// 		CommitID: github.String("3796f797adebb08b0f9d1848c1d2fc34abfb302e"),
// 	}
// 	fmt.Println(pul)
// 	//pr, resp, err := client.PullRequests.CreateComment(ctx, "eduardokenjimiura", "Fiap-Python", 14, &pul)
// 	//fmt.Println("pr: ", pr, "response: ", resp, "EROOOOOOOOOOOOOOOO: ", err)
// 	pulOPton := github.PullRequestOptions{
// 		MergeMethod: "merge",
// 	}
// 	pr, resp, err := client.PullRequests.Merge(ctx, "eduardokenjimiura", "Fiap-Python", 14, "COMITADO", &pulOPton)

// 	//repos, response, err := client.Repositories.ListAll(ctx, nil)
// 	fmt.Println("pr: ", pr, "response: ", resp, "EROOOOOOOOOOOOOOOO: ", err)

// 	Tag := github.Tag{
// 		Tag:     github.String("v0.0.1"),
// 		Message: github.String("(Initial Fuck version)"),
// 		Object:  &github.GitObject{SHA: github.String("3796f797adebb08b0f9d1848c1d2fc34abfb302e"), Type: github.String("commit")},
// 	}
// 	fmt.Println("-------------------------------------------------: ")
// 	tag, ressp, e := client.Git.CreateTag(ctx, "eduardokenjimiura", "Fiap-Python", &Tag)
// 	fmt.Println("tag: ", tag, "resp: ", ressp.Body, "EROOOOOOOOOOOOOOOO: ", e)
// 	fmt.Println("----------------------------------------------------: ")
// 	fmt.Println("----------------------------------------------------: ")
// 	fmt.Println("----------------------------------------------------: ")

// 	b, err := json.Marshal(tag)
// 	if err != nil {
// 		fmt.Println(err)
// 		return
// 	}
// 	fmt.Println(string(b))

// 	fmt.Println("----------------------------------------------------: ")
// 	fmt.Println("----------------------------------------------------: ")
// 	fmt.Println("----------------------------------------------------: ")
// 	decoder := json.NewDecoder(ressp.Body)
// 	var t interface{}
// 	decoder.Decode(&t)
// 	if err != nil {
// 		panic(err)
// 	}
// 	fmt.Println(t)
// 	//psr, ss, erro := client.Repositories.ListTags(ctx, "eduardokenjimiura", "Fiap-Python", nil)
// 	//s := github.Stringify(psr[0].Name)
// 	//fmt.Println("pr: ", s, "response: ", ss, "EROOOOOOOOOOOOOOOO: ", erro)
// }
